# ЧАСТЬ 1 - НАЧАЛО РАБОТЫ

Rx - это библиотека .NET для обработки потоков событий. Зачем она может понадобиться?

Пользователи хотят получать своевременную информацию. Если вы ждете доставку посылки, живые отчеты о продвижении фургона доставки дают вам больше свободы, чем подозрительное двухчасовое окно доставки. Финансовые приложения зависят от непрерывных потоков актуальных данных. Мы ожидаем, что наши телефоны и компьютеры будут предоставлять нам всевозможные важные уведомления. А некоторые приложения просто не могут работать без живой информации. Инструменты для онлайн-сотрудничества и многопользовательские игры абсолютно зависят от быстрого распространения и доставки данных.

Короче говоря, наши системы должны реагировать, когда происходит что-то интересное.

Потоки живой информации являются базовым, вездесущим элементом компьютерных систем. Несмотря на это, они часто являются гражданами второго сорта в языках программирования. Большинство языков поддерживают последовательности данных через что-то вроде массива, который предполагает, что данные сидят в памяти, готовые к чтению нашим кодом в удобное для него время. Если ваше приложение имеет дело с событиями, массивы могут работать для исторических данных, но они не являются хорошим способом представления событий, происходящих во время работы приложения. И хотя концепция потоковых данных довольно почтенна в вычислительной технике, она, как правило, неуклюжа, с абстракциями, часто представленными через API, которые плохо интегрированы с системой типов нашего языка программирования.

Это плохо. Живые данные критически важны для широкого спектра приложений. Работать с ними должно быть так же легко, как со списками, словарями и другими коллекциями.

Reactive Extensions для .NET (Rx.NET или просто Rx, доступны как NuGet-пакет System.Reactive) поднимают источники живых данных до статуса первоклассных граждан. Rx не требует какой-либо специальной поддержки языка программирования. Он использует систему типов .NET для представления потоков данных таким образом, что языки .NET, такие как C#, F# и VB.NET, могут работать с ними так же естественно, как они используют типы коллекций.

(Краткое грамматическое отступление: хотя фраза "Reactive Extensions" является множественным числом, когда мы сокращаем ее до просто Rx.NET или Rx, мы относимся к ней как к существительному в единственном числе. Это непоследовательно, но говорить "Rx are..." звучит просто странно.)

Например, C# предлагает интегрированные функции запросов, которые мы могли бы использовать для поиска всех записей в списке, соответствующих некоторым критериям. Если у нас есть переменная List<Trade> trades, мы могли бы написать следующее:

```csharp
var bigTrades =
from trade in trades
where trade.Volume > 1_000_000;
```

С Rx мы могли бы использовать точно такой же код с живыми данными. Вместо того, чтобы быть List<Trade>, переменная trades могла бы быть IObservable<Trade>.

IObservable<T> - это фундаментальная абстракция в Rx. По сути, это живая версия IEnumerable<T>. В данном случае bigTrades также будет IObservable<Trade>, живым источником данных, способным уведомлять нас обо всех сделках, объем которых превышает один миллион. Что важно, он может сообщать о каждой такой сделке немедленно - это то, что мы подразумеваем под "живым" источником данных.

Rx - это мощный инструмент повышения производительности разработки. Он позволяет разработчикам работать с живыми потоками событий, используя языковые возможности, знакомые всем разработчикам .NET. Он позволяет использовать декларативный подход, который часто позволяет выражать сложное поведение более элегантно и с меньшим количеством кода, чем это было бы возможно без Rx.

Rx строится на основе LINQ (Language Integrated Query). Это позволяет нам использовать синтаксис запросов, показанный выше (или вы можете использовать подход с явным вызовом функций, который предпочитают некоторые разработчики .NET). LINQ широко используется в .NET как для доступа к данным (например, в Entity Framework Core), так и для работы с коллекциями в памяти (с LINQ to Objects), что означает, что опытные разработчики .NET будут чувствовать себя как дома с Rx.

Что важно, LINQ - это высоко композиционный дизайн: вы можете соединять операторы вместе в любой комбинации, которую захотите, выражая потенциально сложную обработку простым способом. Эта композиционность возникает из математических основ его дизайна, но хотя вы можете узнать об этом аспекте LINQ, если захотите, это не является необходимым условием: разработчики, которые не интересуются математикой, стоящей за этим, могут просто наслаждаться тем фактом, что поставщики LINQ, такие как Rx, предоставляют набор строительных блоков, которые можно соединять бесконечным количеством различных способов, и все это просто работает.

LINQ имеет проверенный послужной список обработки очень больших объемов данных. Microsoft широко использовала его во внутренней реализации некоторых своих систем, включая сервисы, поддерживающие десятки миллионов активных пользователей.

Rx разработан для обработки последовательностей событий, что означает, что он лучше подходит для одних сценариев, чем для других. В следующих разделах описываются некоторые из этих сценариев, а также случаи, когда его использование менее очевидно, но все же стоит рассмотреть. Наконец, мы описываем некоторые случаи, в которых возможно использовать Rx, но где альтернативы, вероятно, будут лучше.

Rx хорошо подходит для представления событий, которые происходят извне вашего кода и на которые ваше приложение должно реагировать, таких как:

▪ События интеграции, такие как трансляция из шины сообщений, или событие push из API WebSockets, или сообщение, полученное через MQTT или другое низкозатратное промежуточное ПО, такое как Azure Event Grid, Azure Event Hubs и Azure Service Bus, или не зависящее от поставщика представление, такое как cloudevents
▪ Телеметрия от устройств мониторинга, таких как датчик потока в инфраструктуре водоснабжения, или функции мониторинга и диагностики в сетевом оборудовании провайдера широкополосной связи
▪ Данные о местоположении от мобильных систем, таких как сообщения AIS с кораблей, или автомобильная телеметрия
▪ События операционной системы, такие как активность файловой системы или события WMI
▪ Информация о дорожном движении, такая как уведомления о происшествиях или изменениях средней скорости
▪ Интеграция с механизмом обработки сложных событий (CEP)
▪ События пользовательского интерфейса, такие как движение мыши или щелчки кнопок

Rx также хорошо подходит для моделирования доменных событий. Они могут возникать в результате некоторых из только что описанных событий, но после их обработки для создания событий, которые более непосредственно представляют концепции приложения. К ним могут относиться:

▪ Изменения свойств или состояния доменных объектов, такие как "Статус заказа обновлен" или "Регистрация принята"
▪ Изменения в коллекциях доменных объектов, такие как "Создана новая регистрация"

События также могут представлять собой выводы, полученные из входящих событий (или исторических данных, анализируемых в более позднее время), такие как:

▪ Клиент широкополосной связи мог стать непреднамеренным участником DDoS-атаки
▪ Два океанских судна продемонстрировали схему движения, часто связанную с незаконной деятельностью (например, движение близко друг к другу в течение длительного периода времени, достаточного для передачи груза или людей, находясь далеко в море)
▪ Подшипник оси №4 фрезерного станка с ЧПУ MFZH12 проявляет признаки износа со значительно более высокой скоростью, чем номинальный профиль
▪ Если пользователь хочет вовремя прибыть на встречу на другом конце города, текущие дорожные условия предполагают, что ему следует выехать в течение следующих 10 минут

Эти три набора примеров показывают, как приложения могут постепенно увеличивать ценность информации по мере обработки событий. Мы начинаем с необработанных событий, которые затем улучшаем для создания событий, специфичных для домена, а затем выполняем анализ для создания уведомлений, которые действительно будут важны для пользователей приложения. Каждый этап обработки увеличивает ценность сообщений, которые появляются. Каждый этап обычно также уменьшает объем сообщений. Если бы мы представляли необработанные события в первой категории непосредственно пользователям, они могли бы быть перегружены объемом сообщений, что делало бы невозможным заметить важные события. Но если мы представляем им уведомления только тогда, когда наша обработка обнаружила что-то важное, это позволит им работать более эффективно и точно, потому что мы резко улучшили соотношение сигнал/шум.

Библиотека System.Reactive предоставляет инструменты для создания именно такого процесса добавления ценности, в котором мы укрощаем высокообъемные исходные источники событий для получения высокоценных, живых, действенных выводов. Она предоставляет набор операторов, которые позволяют нашему коду декларативно выражать этот вид обработки, как вы увидите в последующих главах.

Rx также хорошо подходит для введения и управления параллелизмом с целью разгрузки. То есть, выполнение заданного набора работ параллельно, чтобы поток, который обнаружил событие, не должен был также быть потоком, который обрабатывает это событие. Очень популярное использование этого - поддержание отзывчивого пользовательского интерфейса. (Обработка событий пользовательского интерфейса стала настолько популярным использованием Rx - как в .NET, так и в RxJS, который возник как ответвление Rx.NET - что легко подумать, что это то, для чего он предназначен. Но его успех там не должен ослеплять нас от его более широкой применимости.)

Вы должны рассмотреть возможность использования Rx, если у вас есть существующий IEnumerable<T>, который пытается моделировать живые события. Хотя IEnumerable<T> может моделировать данные в движении (используя ленивое вычисление, как yield return), есть проблема. Если код, потребляющий коллекцию, достиг точки, где он хочет получить следующий элемент (например, потому что цикл foreach только что завершил итерацию), но элемент еще не доступен, реализация IEnumerable<T> не имела бы выбора, кроме как блокировать вызывающий поток в своем MoveNext до тех пор, пока данные не станут доступными, что может вызвать проблемы масштабируемости в некоторых приложениях. Даже в случаях, когда блокировка потока приемлема (или если вы используете более новый IAsyncEnumerable<T>, который может использовать функцию await foreach в C#, чтобы избежать блокировки потока в этих случаях), IEnumerable<T> и IAsyncEnumerable<T> являются вводящими в заблуждение типами для представления источников живой информации. Эти интерфейсы представляют модель программирования "pull": код запрашивает следующий элемент в последовательности. Rx является более естественным выбором для моделирования источников информации, которые естественным образом производят информацию по своему собственному расписанию.

Rx можно использовать для представления асинхронных операций. Task или Task<T> в .NET по сути представляют одно событие, а IObservable<T> можно рассматривать как обобщение этого на последовательность событий. (Отношение между, скажем, Task<int> и IObservable<int> аналогично отношению между int и IEnumerable<int>.)

Это означает, что существуют некоторые сценарии, которые можно обрабатывать либо с использованием задач и ключевого слова async, либо через Rx. Если в какой-то момент вашей обработки вам нужно иметь дело как с множественными значениями, так и с одиночными значениями, Rx может справиться с обоими; задачи не так хорошо справляются с множественными элементами. У вас может быть Task<IEnumerable<int>>, который позволяет вам ожидать коллекцию, и это нормально, если все элементы в коллекции могут быть собраны за один шаг. Ограничение здесь в том, что как только задача произвела свой результат IEnumerable<int>, ваше ожидание завершилось, и вы возвращаетесь к неасинхронной итерации по этому IEnumerable<int>. Если данные не могут быть получены за один шаг - возможно, IEnumerable<int> представляет данные из API, в котором результаты извлекаются партиями по 100 элементов за раз - его MoveNext будет вынужден блокировать ваш поток каждый раз, когда нужно ждать.

В течение первых 5 лет своего существования Rx, возможно, был лучшим способом представления коллекций, которые не обязательно имели бы все элементы доступными немедленно. Однако введение IAsyncEnumerable<T> в .NET Core 3.0 и C# 8 предоставило способ обработки последовательностей, оставаясь в мире async / await (и пакет NuGet Microsoft.Bcl.AsyncInterfaces делает это доступным в .NET Framework и .NET Standard 2.0). Поэтому выбор использования Rx теперь, как правило, сводится к тому, является ли модель "pull" (примером которой является foreach или await foreach) или модель "push" (в которой код предоставляет обратные вызовы для вызова источником событий, когда элементы становятся доступными) лучшим соответствием для моделируемых концепций.

Еще одна связанная функция, которая была добавлена в .NET с момента появления Rx - это каналы (channels). Они позволяют источнику производить объекты, а потребителю их обрабатывать, поэтому есть очевидное поверхностное сходство с Rx. Однако отличительной особенностью Rx является его поддержка композиции с обширным набором операторов, чему нет прямого эквивалента в каналах. Каналы, с другой стороны, предоставляют больше вариантов для адаптации к вариациям скорости производства и потребления.

Ранее я упоминал о разгрузке: использовании Rx для переноса работы на другие потоки. Хотя эта техника может позволить Rx вводить и управлять параллелизмом для целей масштабирования или выполнения параллельных вычислений, другие специализированные фреймворки, такие как TPL (Task Parallel Library) Dataflow или PLINQ, более подходят для выполнения параллельных вычислительно-интенсивных работ. Однако TPL Dataflow предлагает некоторую интеграцию с Rx через свои методы расширения AsObserver и AsObservable. Поэтому часто используют Rx для интеграции TPL Dataflow с остальной частью вашего приложения.

IObservable<T> Rx не является заменой для IEnumerable<T> или IAsyncEnumerable<T>. Было бы ошибкой взять что-то, что естественно основано на модели "pull", и заставить его быть основанным на модели "push".

Кроме того, есть некоторые ситуации, когда простота программной модели Rx может работать против вас. Например, некоторые технологии очередей сообщений, такие как MSMQ, по определению являются последовательными и, таким образом, могут выглядеть хорошо подходящими для Rx. Однако они часто выбираются для их поддержки обработки транзакций. Rx не имеет прямого способа представить семантику транзакций, поэтому в сценариях, которые требуют этого, вам может быть лучше просто работать напрямую с API соответствующей технологии. (Тем не менее, Reaqtor добавляет долговечность и сохранение в Rx, поэтому вы, возможно, сможете использовать его для интеграции этих видов систем очередей с Rx.)

Выбирая лучший инструмент для работы, ваш код должен быть легче в обслуживании, вероятно, обеспечит лучшую производительность, и вы, вероятно, получите лучшую поддержку.

Вы можете очень быстро начать работу с простым примером Rx. Если у вас установлен .NET SDK, вы можете запустить следующее в командной строке:

```
mkdir TryRx
cd TryRx
dotnet new console
dotnet add package System.Reactive
```

Альтернативно, если у вас установлена Visual Studio, создайте новый проект консольного приложения .NET, а затем используйте менеджер пакетов NuGet для добавления ссылки на System.Reactive.

Этот код создает наблюдаемый источник (ticks), который производит событие каждую секунду. Код также передает обработчик этому источнику, который выводит сообщение в консоль для каждого события:

```csharp
using System.Reactive.Linq;

IObservable<long> ticks = Observable.Timer(
    dueTime: TimeSpan.Zero,
    period: TimeSpan.FromSeconds(1));
ticks.Subscribe(
    tick => Console.WriteLine($"Tick {tick}"));
Console.ReadLine();
```

Если это не кажется очень захватывающим, то это потому, что это настолько базовый пример, насколько это возможно, и в своей основе Rx имеет очень простую модель программирования. Сила приходит из композиции - мы можем использовать строительные блоки в библиотеке System.Reactive для описания обработки, которая переведет нас от сырых, низкоуровневых событий к высокоценным инсайтам. Но для этого мы должны сначала понять ключевые типы Rx, IObservable<T> и IObserver<T>.
