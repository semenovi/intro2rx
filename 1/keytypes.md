# КЛЮЧЕВЫЕ ТИПЫ

Rx - это мощный фреймворк, который может значительно упростить код, реагирующий на события. Но для написания хорошего реактивного кода необходимо понимать основные концепции. Фундаментальным строительным блоком Rx является интерфейс `IObservable<T>`. Понимание этого интерфейса и его партнера `IObserver<T>` - ключ к успеху с Rx.

В предыдущей главе было показано такое LINQ-выражение запроса в качестве первого примера:

```csharp
var bigTrades =
    from trade in trades
    where trade.Volume > 1_000_000;
```

Большинство .NET-разработчиков знакомы с LINQ по крайней мере в одной из его многих популярных форм, таких как LINQ to Objects или запросы Entity Framework Core. Большинство реализаций LINQ позволяют запрашивать данные в покое. LINQ to Objects работает с массивами или другими коллекциями, а LINQ-запросы в Entity Framework Core выполняются для данных в базе данных, но Rx отличается: он предлагает возможность определять запросы для живых потоков событий - то, что можно назвать данными в движении.

Если вам не нравится синтаксис выражений запросов, вы можете написать точно такой же код, вызывая операторы LINQ напрямую:

```csharp
var bigTrades = trades.Where(trade => trade.Volume > 1_000_000);
```

Какой бы стиль мы ни использовали, это способ LINQ сказать, что мы хотим, чтобы `bigTrades` содержал только те элементы из `trades`, где свойство `Volume` больше одного миллиона.

Мы не можем точно сказать, что делают эти примеры, потому что не видим типы переменных `trades` или `bigTrades`. Значение этого кода будет сильно различаться в зависимости от этих типов. Если бы мы использовали LINQ to Objects, оба они, вероятно, были бы `IEnumerable<Trade>`. Это означало бы, что эти переменные ссылаются на объекты, представляющие коллекции, содержимое которых мы могли бы перечислить с помощью цикла foreach. Это представляло бы данные в покое, данные, которые наш код мог бы проверять напрямую.

Но давайте прояснить, что означает код, явно указав тип:

```csharp
IObservable<Trade> bigTrades = trades.Where(trade => trade.Volume > 1_000_000);
```

Это устраняет неоднозначность. Теперь ясно, что мы имеем дело не с данными в покое. Мы работаем с `IObservable<Trade>`. Но что именно это такое?

## IObservable<T>

Интерфейс `IObservable<T>` представляет фундаментальную абстракцию Rx: последовательность значений некоторого типа T. В очень абстрактном смысле это означает, что он представляет то же самое, что и `IEnumerable<T>`.

Разница заключается в том, как код потребляет эти значения. В то время как `IEnumerable<T>` позволяет коду извлекать значения (обычно с помощью цикла foreach), `IObservable<T>` предоставляет значения, когда они становятся доступными. Это различие иногда характеризуется как push vs pull. Мы можем извлекать значения из `IEnumerable<T>`, выполняя цикл foreach, но `IObservable<T>` будет передавать значения в наш код.

Как `IObservable<T>` может передавать свои значения в наш код? Если мы хотим получать эти значения, наш код должен подписаться на `IObservable<T>`, что означает предоставление ему некоторых методов, которые он может вызывать. Фактически, подписка - это единственная операция, которую `IObservable<T>` поддерживает напрямую. Вот полное определение интерфейса:

```csharp
public interface IObservable<out T>
{
    IDisposable Subscribe(IObserver<T> observer);
}
```

Вы можете увидеть исходный код `IObservable<T>` на GitHub. Обратите внимание, что он является частью библиотек времени выполнения .NET, а не пакета NuGet System.Reactive. `IObservable<T>` представляет настолько фундаментально важную абстракцию, что она встроена в .NET. (Так что вы можете задаться вопросом, для чего нужен пакет NuGet System.Reactive. Библиотеки времени выполнения .NET определяют только интерфейсы `IObservable<T>` и `IObserver<T>`, а не реализацию LINQ. Пакет NuGet System.Reactive предоставляет нам поддержку LINQ, а также занимается многопоточностью.)

Единственный метод этого интерфейса ясно показывает, что мы можем делать с `IObservable<T>`: если мы хотим получать события, которые он может предложить, мы можем подписаться на него. (Мы также можем отписаться: метод Subscribe возвращает `IDisposable`, и если мы вызовем Dispose на нем, это отменит нашу подписку.) Метод Subscribe требует, чтобы мы передали реализацию `IObserver<T>`, к которой мы скоро перейдем.

Внимательные читатели заметят, что пример в предыдущей главе выглядит так, будто он не должен работать. Этот код создал `IObservable<long>`, который производил события раз в секунду, а затем подписался на него с помощью этого кода:

```csharp
ticks.Subscribe(
    tick => Console.WriteLine($"Tick {tick}"));
```

Это передает делегат, а не `IObserver<T>`, который требует `IObservable<T>.Subscribe`. Мы скоро перейдем к `IObserver<T>`, но все, что здесь происходит, это использование метода расширения из пакета NuGet System.Reactive:

```csharp
// Из класса ObservableExtensions библиотеки System.Reactive
public static IDisposable Subscribe<T>(this IObservable<T> source, Action<T> onNext)
```

Это вспомогательный метод, который оборачивает делегат в реализацию `IObserver<T>` и затем передает его в `IObservable<T>.Subscribe`. Эффект заключается в том, что мы можем написать просто простой метод (вместо полной реализации `IObserver<T>`), и наблюдаемый источник будет вызывать наш обратный вызов каждый раз, когда он хочет предоставить значение. Чаще всего используется такой вид помощника, чем реализация интерфейсов Rx самостоятельно.

Поскольку `IObservable<T>` не может предоставить нам значения, пока мы не подпишемся, время, в которое мы подписываемся, может быть важным. Представьте `IObservable<Trade>`, описывающий сделки, происходящие на некотором рынке. Если предоставляемая им информация актуальна, он не сообщит вам о сделках, которые произошли до вашей подписки. В Rx источники такого рода описываются как горячие.

Не все источники горячие. Ничто не мешает `IObservable<T>` всегда предоставлять точно такую же последовательность событий любому подписчику, независимо от того, когда происходит вызов Subscribe. (Представьте `IObservable<Trade>`, который вместо сообщения о живой информации генерирует уведомления на основе записанных исторических данных о сделках.) Источники, где совершенно не имеет значения, когда вы подписываетесь, известны как холодные источники.

Вот некоторые источники, которые могут быть представлены как горячие наблюдаемые:

- Измерения от датчика
- Тики цен с торговой биржи
- Источник событий, который распространяет события немедленно, такой как Azure Event Grid
- Движения мыши
- События таймера
- Трансляции, такие как каналы ESB или сетевые пакеты UDP

И некоторые примеры источников, которые могут быть хорошими холодными наблюдаемыми:

- Содержимое коллекции (такое, как возвращается методом расширения ToObservable для `IEnumerable<T>`)
- Фиксированный диапазон значений, такой как производит Observable.Range
- События, генерируемые на основе алгоритма, такие как производит Observable.Generate
- Фабрика для асинхронной операции, такая как возвращает FromAsync
- События, производимые выполнением обычного кода, например цикла; вы можете создавать такие источники с помощью Observable.Create
- Поставщик потоковых событий, такой как Azure Event Hub или Kafka (или любой другой источник в стиле потока, который удерживает события из прошлого, чтобы иметь возможность доставлять события с определенного момента в потоке; так что не источник событий в стиле Azure Event Grid)

Не все источники строго полностью горячие или холодные. Например, можно представить небольшое изменение живого `IObservable<Trade>`, где источник всегда сообщает о самой последней сделке новым подписчикам. Подписчики могут рассчитывать на немедленное получение чего-то и затем будут получать обновления по мере поступления новой информации. Тот факт, что новые подписчики всегда будут получать (потенциально довольно старую) информацию, является характеристикой, похожей на холодную, но только это первое событие холодное. Все еще вероятно, что совершенно новый подписчик пропустит много информации, которая была бы доступна более ранним подписчикам, что делает этот источник более горячим, чем холодным.

Есть интересный особый случай, когда источник событий был разработан так, чтобы приложения могли получать каждое отдельное событие по порядку, ровно один раз. Системы потоковой передачи событий, такие как Kafka или Azure Event Hub, имеют эту характеристику - они сохраняют события на некоторое время, чтобы гарантировать, что потребители не пропустят их, даже если они время от времени отстают. Стандартный ввод (stdin) для процесса также имеет эту характеристику: если вы запустите инструмент командной строки и начнете вводить данные до того, как он будет готов их обработать, операционная система будет удерживать этот ввод в буфере, чтобы гарантировать, что ничего не будет потеряно. Windows делает что-то похожее для настольных приложений: каждый поток приложения получает очередь сообщений, поэтому если вы щелкаете или набираете текст, когда оно не может ответить, ввод в конечном итоге будет обработан. Мы можем думать об этих источниках как о холодных, а затем горячих. Они похожи на холодные источники в том, что мы не пропустим ничего только потому, что нам потребовалось некоторое время, чтобы начать получать события, но как только мы начнем получать данные, мы обычно не сможем перемотать назад к началу. Так что как только мы запустимся, они больше похожи на горячие события.

Этот вид холодно-горячего источника может представлять проблему, если мы хотим подключить несколько подписчиков. Если источник начинает предоставлять события, как только происходит подписка, то это нормально для самого первого подписчика: он получит любые события, которые были отложены в ожидании нашего запуска. Но если мы хотим подключить несколько подписчиков, у нас возникает проблема: первый подписчик может получить все уведомления, которые сидели в ожидании в каком-то буфере, прежде чем мы успеем подключить второго подписчика. Второй подписчик пропустит их.

В этих случаях нам действительно нужен какой-то способ настроить всех наших подписчиков перед тем, как начать. Мы хотим, чтобы подписка была отдельна от акта запуска. По умолчанию подписка на источник подразумевает, что мы хотим, чтобы он начал работу, но Rx определяет специализированный интерфейс, который может дать нам больше контроля: `IConnectableObservable<T>`. Он наследуется от `IObservable<T>` и добавляет всего один метод, Connect:

```csharp
public interface IConnectableObservable<out T> : IObservable<T>
{
    IDisposable Connect();
}
```

Это полезно в тех сценариях, где будет какой-то процесс, который извлекает или генерирует события, и нам нужно убедиться, что мы подготовлены, прежде чем он начнется. Поскольку `IConnectableObservable<T>` не начнет работу, пока вы не вызовете Connect, он предоставляет вам способ подключить столько подписчиков, сколько вам нужно, прежде чем события начнут поступать.

"Температура" источника не всегда очевидна из его типа. Даже когда базовый источник является `IConnectableObservable<T>`, это часто может быть скрыто за слоями кода. Так что независимо от того, является ли источник горячим, холодным или чем-то промежуточным, в большинстве случаев мы просто видим `IObservable<T>`. Поскольку `IObservable<T>` определяет только один метод, Subscribe, вы можете задаться вопросом, как мы можем сделать с ним что-то интересное. Сила приходит от операторов LINQ, которые предоставляет библиотека NuGet System.Reactive.

До сих пор я показывал только очень простой пример LINQ, использующий оператор Where для фильтрации событий до тех, которые соответствуют определенным критериям. Чтобы дать вам представление о том, как мы можем создавать более продвинутую функциональность через композицию, я собираюсь представить пример сценария.

Предположим, вы хотите написать программу, которая наблюдает за какой-то папкой в файловой системе и выполняет автоматическую обработку каждый раз, когда что-то в этой папке изменяется. Например, веб-разработчики часто хотят запускать автоматические пересборки своего клиентского кода, когда они сохраняют изменения в редакторе, чтобы быстро увидеть эффект своих изменений.

Изменения в файловой системе часто происходят пакетами. Текстовые редакторы могут выполнять несколько отдельных операций при сохранении файла. (Некоторые сохраняют изменения в новый файл, а затем выполняют пару переименований после завершения, потому что это позволяет избежать потери данных, если сбой питания или системный сбой происходит в момент сохранения файла.) Поэтому обычно вы не захотите предпринимать действия, как только обнаружите активность файла. Было бы лучше подождать момент, чтобы увидеть, не произойдет ли еще какая-либо активность, и предпринять действия только после того, как все успокоится.

Таким образом, мы не должны реагировать непосредственно на активность файловой системы. Мы хотим предпринимать действия в те моменты, когда все становится тихим после всплеска активности. Rx не предлагает эту функциональность напрямую, но мы можем создать пользовательский оператор, комбинируя некоторые из встроенных операторов. Следующий код определяет оператор Rx, который обнаруживает и сообщает о таких вещах. Если вы новичок в Rx (что кажется вероятным, если вы читаете это), вероятно, не будет сразу понятно, как это работает. Это значительный шаг вперед в сложности по сравнению с примерами, которые я показывал до сих пор, потому что это взято из реального приложения. Но я пройдусь по этому шаг за шагом, так что все станет ясно.

```csharp
static class RxExt
{
    public static IObservable<IList<T>> Quiescent<T>(
        this IObservable<T> src,
        TimeSpan minimumInactivityPeriod,
        IScheduler scheduler)
    {
        IObservable<int> onoffs =
            from _ in src
            from delta in
                Observable.Return(1, scheduler)
                    .Concat(Observable.Return(-1, scheduler)
                        .Delay(minimumInactivityPeriod, scheduler))
            select delta;

        IObservable<int> outstanding = onoffs.Scan(0, (total, delta) => total + delta);
        IObservable<int> zeroCrossings = outstanding.Where(total => total == 0);
        return src.Buffer(zeroCrossings);
    }
}
```

Первое, что нужно сказать об этом, это то, что мы фактически определяем пользовательский оператор в стиле LINQ: это метод расширения, который, как и все операторы LINQ, которые предоставляет Rx, принимает `IObservable<T>` в качестве неявного аргумента и производит другой наблюдаемый источник в качестве результата. Тип возвращаемого значения немного отличается: это `IObservable<IList<T>>`. Это потому, что после возвращения в состояние неактивности мы захотим обработать все, что только что произошло, поэтому этот оператор будет производить список, содержащий каждое значение, о котором источник сообщил в своем последнем всплеске активности.

Когда мы хотим показать, как работает оператор Rx, мы обычно рисуем диаграмму "мрамора". Это диаграмма, показывающая один или несколько источников событий `IObservable<T>`, каждый из которых иллюстрируется горизонтальной линией. Каждое событие, которое производит источник, иллюстрируется кругом (или "мрамором") на этой линии, причем горизонтальное положение представляет время. Обычно линия имеет вертикальную планку слева, указывающую момент, когда приложение подписалось на источник, если только он не производит события немедленно, в этом случае он начнется с мрамора. Если линия имеет стрелку справа, это указывает на то, что время жизни наблюдаемого объекта выходит за пределы диаграммы. Вот диаграмма, показывающая, как оператор Quiescent выше реагирует на конкретный ввод:

[Здесь была бы диаграмма, но я не могу ее воспроизвести в текстовом формате]

Это показывает, что источник (верхняя линия) произвел пару событий (значения 1 и 2 в этом примере), а затем остановился на некоторое время. Через некоторое время после того, как он остановился, наблюдаемый объект, возвращенный оператором Quiescent (нижняя линия), произвел одно событие со списком, содержащим оба этих события ([1,2]). Затем источник снова начал работу, производя значения 3, 4 и 5 довольно быстро друг за другом, а затем снова затих на некоторое время. Опять же, как только период тишины длился достаточно долго, источник, возвращенный Quiescent, произвел одно событие, содержащее все события источника из этого второго всплеска активности ([3,4,5]). А затем последний бит активности источника, показанный на этой диаграмме, состоит из одного события, 6, за которым следует еще одна неактивность, и снова, как только неактивность длилась достаточно долго, источник Quiescent производит одно событие, чтобы сообщить об этом. И поскольку этот последний "всплеск" активности от источника содержал только одно событие, список, сообщенный этим окончательным выходом из наблюдаемого Quiescent, является списком с одним значением: [6].

Так как же код, показанный выше, достигает этого? Первое, что нужно заметить о методе Quiescent, это то, что он просто использует другие операторы LINQ Rx (операторы Return, Scan, Where и Buffer явно видны, а выражение запроса будет использовать оператор SelectMany, потому что это то, что делают выражения запросов C#, когда они содержат два предложения from подряд) в комбинации, которая производит окончательный вывод `IObservable<IList<T>>`.

Это композиционный подход Rx, и это то, как мы обычно используем Rx. Мы используем смесь операторов, объединенных (скомпонованных) таким образом, чтобы получить нужный нам эффект.
